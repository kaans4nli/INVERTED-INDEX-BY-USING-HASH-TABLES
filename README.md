# INVERTED-INDEX-BY-USING-HASH-TABLES

An **inverted index** is an index data structure, which is used to map all documents with their content. It keeps a word and all documents containing this word. There are two types of inverted indexes:

* **Record-level inverted index** contains a list of references to documents for each word.
* **Word-level inverted index** contains the positions of each word within a document.

Inverted index allows fast full text searches and is the most popular data structure used in document retrieval systems, used on a large scale for example in search engines. Its disadvantage is large storage overhead and high maintenance costs on update, delete, and insert.

A record-level inverted index structure using hash table implementation in Java programming language. İndex structure will be used to find all documents that contain a particular word (e.g., return all documents in which "computer" occurs).

To build an inverted index, fetch all the documents, ignore any punctuation mark, remove stop words (stop words are the most frequent and useless words in documents, such as “I”, “the”, “we”, “is”, “an”), and then index each document with the remaining words. The structure of the inverted index, implemented with a hash table, should look like as below:

![image](https://github.com/kaans4nli/INVERTED-INDEX-BY-USING-HASH-TABLES/assets/107371841/869a7cfc-d8bd-4696-9a4f-03cd5d7abc03)

1. **Main Functionalities**
   * put(Key k, Value v)
     
     If a word (k) is already present, then add a reference of the document (v) to the index; otherwise create a new entry. Store the frequency of each word with the document identifier.
     
   * Value get(Key k)
     
     Search the given word (k) in the hash table. If the word is available in the table, then return an output as shown below, otherwise return a “not found” message to the user.
     
     ![image](https://github.com/kaans4nli/INVERTED-INDEX-BY-USING-HASH-TABLES/assets/107371841/01ad3607-5ea1-4b07-8dea-c933bd02f7c6)
     
   * remove(Key k)
     
     Remove the given word (k) and the associated value from the inverted index.
     
   * resize(int capacity)
     
     Make the hash table dynamically growable. Put method double the current table size if the hash table reach the maximum load factor.

2. **Hash Function**
   
   To specify an index corresponding to given string key, firstly generate an integer hash code by using a special function. Then, resulting hash code has to be converted to the range 0 to N-1 using a compression function, such as modulus operator (N is the size of hash table).

   * Simple Summation Function (SSF)

     Generate the hash code of a string s with the length n simply by the following formula:

     ![image](https://github.com/kaans4nli/INVERTED-INDEX-BY-USING-HASH-TABLES/assets/107371841/99288908-f11b-4925-8565-12e15ee91f5c)

   * Polynomial Accumulation Function (PAF)

     The hash code of a string s can also be generated by using the following polynomial:
     
     ![image](https://github.com/kaans4nli/INVERTED-INDEX-BY-USING-HASH-TABLES/assets/107371841/689b168c-a38c-4015-960e-198a184ef9bb)

     where *ch*<sub>0</sub> is the left most character of the string, characters are represented as numbers in 1-26 (case insensitive), and *n* is the length of the string. The constant *z* is usually a prime number (31, 33, 37, and 41 are particularly good choices for working English words). When the *z* value is chosen as 31, the string "car" has the following hash value:

     ![image](https://github.com/kaans4nli/INVERTED-INDEX-BY-USING-HASH-TABLES/assets/107371841/66113015-92bf-404e-8da6-8630415ab69a)

3. **Collision Handling**
